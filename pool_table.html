<!DOCTYPE html>
<html>
<head>
    <title>Pool Table Visualization</title>
    <style>
        .table-container {
            display: flex;
            justify-content: center;
            margin: 20px;
            cursor: crosshair;
        }
        #aimLine {
            stroke: white;
            stroke-width: 1;
            stroke-dasharray: 5,5;
            pointer-events: none;
            display: none;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="table-container">
        <svg width="800" height="400" viewBox="0 0 800 400">
            <!-- Table frame (brown rails) -->
            <rect x="0" y="0" width="800" height="400" fill="#8B4513" rx="20"/>
            
            <!-- Green felt with cutouts for pockets -->
            <path d="M40 40 
                     L340 40 L460 40 
                     L760 40 L760 360 
                     L460 360 L340 360 
                     L40 360 Z
                     M40 40 A35 35 0 0 0 15 75 L15 325 A35 35 0 0 0 40 360
                     M760 40 A35 35 0 0 1 785 75 L785 325 A35 35 0 0 1 760 360
                     M340 40 A35 35 0 0 0 400 15 A35 35 0 0 0 460 40
                     M340 360 A35 35 0 0 1 400 385 A35 35 0 0 1 460 360"
                  fill="#006400"/>
            
            <!-- Pockets (holes) -->
            <circle cx="15" cy="75" r="25" fill="black"/> <!-- Top left -->
            <circle cx="400" cy="15" r="25" fill="black"/> <!-- Top middle -->
            <circle cx="785" cy="75" r="25" fill="black"/> <!-- Top right -->
            <circle cx="15" cy="325" r="25" fill="black"/> <!-- Bottom left -->
            <circle cx="400" cy="385" r="25" fill="black"/> <!-- Bottom middle -->
            <circle cx="785" cy="325" r="25" fill="black"/> <!-- Bottom right -->
            
            <!-- Cue ball (white) -->
            <circle cx="200" cy="200" r="15" fill="white" stroke="black" stroke-width="1"/>
            
            <!-- Numbered balls -->
            <!-- First row -->
            <circle cx="550" cy="200" r="15" fill="yellow" stroke="black" stroke-width="1"/> <!-- 1 -->
            <circle cx="578" cy="185" r="15" fill="blue" stroke="black" stroke-width="1"/> <!-- 2 -->
            <circle cx="578" cy="215" r="15" fill="red" stroke="black" stroke-width="1"/> <!-- 3 -->
            
            <!-- Second row -->
            <circle cx="606" cy="170" r="15" fill="purple" stroke="black" stroke-width="1"/> <!-- 4 -->
            <circle cx="606" cy="200" r="15" fill="orange" stroke="black" stroke-width="1"/> <!-- 5 -->
            <circle cx="606" cy="230" r="15" fill="green" stroke="black" stroke-width="1"/> <!-- 6 -->
            
            <!-- Third row -->
            <circle cx="634" cy="155" r="15" fill="brown" stroke="black" stroke-width="1"/> <!-- 7 -->
            <circle cx="634" cy="185" r="15" fill="black" stroke="white" stroke-width="1"/> <!-- 8 -->
            <circle cx="634" cy="215" r="15" fill="yellow" stroke="black" stroke-width="1"/> <!-- 9 -->
            <circle cx="634" cy="245" r="15" fill="blue" stroke="black" stroke-width="1"/> <!-- 10 -->
            
            <!-- Fourth row -->
            <circle cx="662" cy="140" r="15" fill="red" stroke="black" stroke-width="1"/> <!-- 11 -->
            <circle cx="662" cy="170" r="15" fill="purple" stroke="black" stroke-width="1"/> <!-- 12 -->
            <circle cx="662" cy="200" r="15" fill="orange" stroke="black" stroke-width="1"/> <!-- 13 -->
            <circle cx="662" cy="230" r="15" fill="green" stroke="black" stroke-width="1"/> <!-- 14 -->
            <circle cx="662" cy="260" r="15" fill="brown" stroke="black" stroke-width="1"/> <!-- 15 -->
            <!-- Aim line -->
            <line id="aimLine" x1="0" y1="0" x2="0" y2="0"/>
        </svg>
    </div>
    <script>
        const svg = document.querySelector('svg');
        const aimLine = document.querySelector('#aimLine');
        let isDragging = false;
        let gameInMotion = false;

        // Track all balls
        const balls = Array.from(document.querySelectorAll('circle')).filter(ball => 
            ball.getAttribute('fill') !== 'black' || ball.getAttribute('stroke') === 'white'
        ).map(ball => ({
            element: ball,
            x: ball.cx.baseVal.value,
            y: ball.cy.baseVal.value,
            vx: 0,
            vy: 0,
            radius: ball.r.baseVal.value,
            isPocketed: false
        }));

        const cueBall = balls.find(ball => ball.element.getAttribute('fill') === 'white');
        
        // Mouse events for aiming
        svg.addEventListener('mousedown', (e) => {
            if (gameInMotion) return;
            isDragging = true;
            aimLine.style.display = 'block';
            updateAimLine(e);
        });

        svg.addEventListener('mousemove', (e) => {
            if (isDragging) {
                updateAimLine(e);
            }
        });

        svg.addEventListener('mouseup', (e) => {
            if (isDragging) {
                shoot(e);
                isDragging = false;
                aimLine.style.display = 'none';
            }
        });

        function updateAimLine(e) {
            const rect = svg.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            aimLine.setAttribute('x1', cueBall.x);
            aimLine.setAttribute('y1', cueBall.y);
            aimLine.setAttribute('x2', x);
            aimLine.setAttribute('y2', y);
        }

        function shoot(e) {
            const rect = svg.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Calculate velocity based on distance
            const dx = x - cueBall.x;
            const dy = y - cueBall.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Scale factor for speed - balanced for realistic breaks
            const power = 0.2;
            cueBall.vx = -(dx / distance) * power * distance;
            cueBall.vy = -(dy / distance) * power * distance;
            
            gameInMotion = true;
            requestAnimationFrame(animate);
        }

        // Define pockets array at a higher scope
        const pockets = [
            {x: 15, y: 75}, {x: 400, y: 15}, {x: 785, y: 75},
            {x: 15, y: 325}, {x: 400, y: 385}, {x: 785, y: 325}
        ];

        function isNearPocket(ball) {
            for (let pocket of pockets) {
                const dx = ball.x - pocket.x;
                const dy = ball.y - pocket.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 40) { // Larger radius for rail bounce prevention
                    return true;
                }
            }
            return false;
        }

        function checkPocket(ball) {
            for (let pocket of pockets) {
                const dx = ball.x - pocket.x;
                const dy = ball.y - pocket.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 25) {
                    // Add a "sinking" effect
                    ball.vx *= 0.5;
                    ball.vy *= 0.5;
                    return true;
                }
            }
            return false;
        }

        function handleCollision(ball1, ball2) {
            const dx = ball2.x - ball1.x;
            const dy = ball2.y - ball1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = ball1.radius + ball2.radius;
            
            if (distance < minDistance) {
                // Calculate the overlap
                const overlap = minDistance - distance;
                
                // Move balls apart proportionally to their velocities
                const totalVelocity = Math.sqrt(
                    (ball1.vx * ball1.vx + ball1.vy * ball1.vy) +
                    (ball2.vx * ball2.vx + ball2.vy * ball2.vy)
                ) || 1; // Prevent division by zero
                
                const ball1Ratio = Math.sqrt(ball1.vx * ball1.vx + ball1.vy * ball1.vy) / totalVelocity;
                const ball2Ratio = Math.sqrt(ball2.vx * ball2.vx + ball2.vy * ball2.vy) / totalVelocity;
                
                // Normal vector
                const nx = dx / distance;
                const ny = dy / distance;
                
                // Separate the balls
                const separation1 = overlap * (1 - ball1Ratio);
                const separation2 = overlap * (1 - ball2Ratio);
                
                ball1.x -= nx * separation1;
                ball1.y -= ny * separation1;
                ball2.x += nx * separation2;
                ball2.y += ny * separation2;
                
                // Relative velocity
                const dvx = ball2.vx - ball1.vx;
                const dvy = ball2.vy - ball1.vy;
                
                // Impact speed
                const impactSpeed = dvx * nx + dvy * ny;
                
                // Don't process collision if balls are moving apart
                if (impactSpeed < 0) {
                    // Collision impulse
                    const impulse = 2 * impactSpeed;
                    
                    // Calculate new velocities (perfect elastic collision with energy loss)
                    const restitution = 0.95; // 5% energy loss on collision for more realistic transfer
                
                    // Calculate new velocities using conservation of momentum
                    const m1 = 1; // All balls have equal mass
                    const m2 = 1;
                    const v1x = ball1.vx;
                    const v1y = ball1.vy;
                    const v2x = ball2.vx;
                    const v2y = ball2.vy;
                
                    ball1.vx = (v1x * (m1 - m2) + (2 * m2 * v2x)) / (m1 + m2) * restitution;
                    ball1.vy = (v1y * (m1 - m2) + (2 * m2 * v2y)) / (m1 + m2) * restitution;
                    ball2.vx = (v2x * (m2 - m1) + (2 * m1 * v1x)) / (m1 + m2) * restitution;
                    ball2.vy = (v2y * (m2 - m1) + (2 * m1 * v1y)) / (m1 + m2) * restitution;
                    
                    // Separate balls to prevent sticking
                    const overlap = (ball1.radius + ball2.radius - distance) / 2;
                    ball1.x -= nx * overlap;
                    ball1.y -= ny * overlap;
                    ball2.x += nx * overlap;
                    ball2.y += ny * overlap;
                }
            }
        }

        function animate() {
            if (!gameInMotion) return;
            
            let anyBallMoving = false;

            // Update all balls
            for (let ball of balls) {
                if (ball.isPocketed) continue;

                // Update position
                ball.x += ball.vx;
                ball.y += ball.vy;

                // Bounce off walls (but only if not near a pocket)
                if (!isNearPocket(ball)) {
                    if (ball.x < 55 || ball.x > 745) {
                        ball.vx *= -0.7;  // Less energy loss on rail bounces
                        ball.x = ball.x < 55 ? 55 : 745;
                    }
                    if (ball.y < 55 || ball.y > 345) {
                        ball.vy *= -0.7;  // Less energy loss on rail bounces
                        ball.y = ball.y < 55 ? 55 : 345;
                    }
                }

                // Apply friction - adjusted for more natural deceleration
                ball.vx *= 0.982;
                ball.vy *= 0.982;

                // Stop balls if moving very slowly - adjusted threshold
                if (Math.abs(ball.vx) < 0.02) ball.vx = 0;
                if (Math.abs(ball.vy) < 0.02) ball.vy = 0;

                // Check if ball is moving
                if (Math.abs(ball.vx) > 0.05 || Math.abs(ball.vy) > 0.05) {
                    anyBallMoving = true;
                }

                // Check if ball is pocketed
                if (!ball.isPocketed && checkPocket(ball)) {
                    ball.isPocketed = true;
                    ball.element.style.display = 'none';
                    continue;
                }

                // Update ball position on screen
                ball.element.setAttribute('cx', ball.x);
                ball.element.setAttribute('cy', ball.y);
            }

            // Check collisions between all pairs of balls
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    if (!balls[i].isPocketed && !balls[j].isPocketed) {
                        handleCollision(balls[i], balls[j]);
                    }
                }
            }

            // Stop animation if no balls are moving
            if (!anyBallMoving) {
                gameInMotion = false;
                return;
            }

            requestAnimationFrame(animate);
        }
    </script>
</body>
</html>
